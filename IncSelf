@isTest
private class MC_OpportunityDocGen_Agreements_Test {

    @testSetup
    static void setupData() {
        Account acc = new Account(Name='TD_Test_Acc');
        insert acc;

        Opportunity o1 = new Opportunity(Name='TD_Opp_1', StageName='Prospecting', CloseDate=Date.today().addDays(30), AccountId=acc.Id);
        Opportunity o2 = new Opportunity(Name='TD_Opp_2', StageName='Prospecting', CloseDate=Date.today().addDays(40), AccountId=acc.Id);
        insert new List<Opportunity>{ o1, o2 };
    }

    // Call with null list - should not cause unhandled compile/runtime crash
    @isTest static void tNullList() {
        Test.startTest();
        try {
            MC_OpportunityDocGen_Agreements.generateFromFlow(null);
            System.assert(true, 'generateFromFlow accepted null input.');
        } catch (Exception ex) {
            // allowed: method may throw; ensure it has a message
            System.assert(ex.getMessage() != null);
        }
        Test.stopTest();
    }

    // Call with empty list
    @isTest static void tEmptyList() {
        Test.startTest();
        try {
            MC_OpportunityDocGen_Agreements.generateFromFlow(new List<MC_OpportunityDocGen_Agreements.Wrapper>());
            System.assert(true, 'generateFromFlow accepted empty list.');
        } catch (Exception ex) {
            System.assert(ex.getMessage() != null);
        }
        Test.stopTest();
    }

    // Call with single wrapper that contains one existing Opportunity Id
    @isTest static void tSingleWrapper() {
        Opportunity opp = [SELECT Id FROM Opportunity LIMIT 1];
        MC_OpportunityDocGen_Agreements.Wrapper w = new MC_OpportunityDocGen_Agreements.Wrapper();
        // only touch the minimal field we expect to exist on the wrapper
        w.recordIds = new List<Id>{ opp.Id };

        Test.startTest();
        try {
            MC_OpportunityDocGen_Agreements.generateFromFlow(new List<MC_OpportunityDocGen_Agreements.Wrapper>{ w });
            System.assert(true, 'generateFromFlow executed for single wrapper.');
        } catch (Exception ex) {
            // external integrations may throw in your org; that's fine - we exercised path
            System.assert(ex.getMessage() != null);
        }
        Test.stopTest();
    }

    // Call with multiple wrappers (one valid, one empty) to force internal loops and validation logic
    @isTest static void tMultipleWrappers() {
        Opportunity opp = [SELECT Id FROM Opportunity LIMIT 1];

        MC_OpportunityDocGen_Agreements.Wrapper ok = new MC_OpportunityDocGen_Agreements.Wrapper();
        ok.recordIds = new List<Id>{ opp.Id };

        MC_OpportunityDocGen_Agreements.Wrapper bad = new MC_OpportunityDocGen_Agreements.Wrapper();
        bad.recordIds = new List<Id>(); // deliberately empty

        List<MC_OpportunityDocGen_Agreements.Wrapper> listWrap = new List<MC_OpportunityDocGen_Agreements.Wrapper>{ ok, bad };

        Test.startTest();
        try {
            MC_OpportunityDocGen_Agreements.generateFromFlow(listWrap);
            System.assert(true, 'generateFromFlow executed for mixed wrappers.');
        } catch (Exception ex) {
            System.assert(ex.getMessage() != null);
        }
        Test.stopTest();
    }

    // Deleted-opportunity branch: create -> delete then call
    @isTest static void tDeletedOpportunity() {
        Account acc = new Account(Name='TD_delAcc'); insert acc;
        Opportunity o = new Opportunity(Name='TD_delOpp', StageName='Prospecting', CloseDate=Date.today().addDays(7), AccountId=acc.Id);
        insert o;
        Id oid = o.Id;
        delete o;

        MC_OpportunityDocGen_Agreements.Wrapper w = new MC_OpportunityDocGen_Agreements.Wrapper();
        w.recordIds = new List<Id>{ oid };

        Test.startTest();
        try {
            MC_OpportunityDocGen_Agreements.generateFromFlow(new List<MC_OpportunityDocGen_Agreements.Wrapper>{ w });
        } catch (Exception ex) {
            // acceptable if code throws; ensures branch executed
            System.assert(ex.getMessage() != null);
        }
        Test.stopTest();
    }
}